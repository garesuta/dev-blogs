# Feature: Role-Based Access Control (RBAC) with Better Auth

## 1. Overview

- **Goal**: Implement three-tier RBAC (Admin, Editor, User) with Google OAuth and email/password authentication
- **Value**: Restrict admin features to authorized users, enable content moderation by editors, protect sensitive operations
- **In Scope**:
  - Better Auth setup with email/password + Google OAuth
  - Three roles: Admin, Editor, User
  - Admin UI for role assignment
  - Protected routes and API endpoints
  - Database schema for auth tables
- **Out of Scope**:
  - Organization/team-level RBAC (single-tenant only)
  - Fine-grained permissions beyond role-based (no ABAC)
  - Multi-factor authentication (can be added later)
  - Email verification (can be added later)
  - Password reset flow UI (can be added later)

## 2. Requirements Summary

| Requirement | Detail | Priority |
|-------------|--------|----------|
| Google OAuth login | Users can sign in with Google account | P0 |
| Email/password login | Users can register and sign in with email | P0 |
| Three-tier roles | Admin, Editor, User with distinct permissions | P0 |
| Protected admin routes | Admin pages only accessible to admins | P0 |
| Role assignment UI | Admins can assign/revoke roles via interface | P1 |
| Content moderation | Editors can manage blog content | P1 |
| Session management | Cookie-based sessions with configurable expiry | P0 |
| Role check < 500ms | Permission checks complete within budget | P1 |

## 3. Architecture & Design

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Astro SSR App                            │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   Pages      │    │  API Routes  │    │  Middleware  │      │
│  │  (*.astro)   │───▶│ /api/auth/*  │◀───│  (auth.ts)   │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│         │                   │                   │               │
│         ▼                   ▼                   ▼               │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              Better Auth Server                      │       │
│  │  ┌─────────┐  ┌─────────────┐  ┌───────────────┐   │       │
│  │  │ Admin   │  │ Email/Pass  │  │ Google OAuth  │   │       │
│  │  │ Plugin  │  │   Auth      │  │   Provider    │   │       │
│  │  └─────────┘  └─────────────┘  └───────────────┘   │       │
│  └─────────────────────────────────────────────────────┘       │
│                            │                                    │
├────────────────────────────┼────────────────────────────────────┤
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────┐       │
│  │              Drizzle ORM + Neon PostgreSQL          │       │
│  │  ┌────────┐ ┌─────────┐ ┌──────────┐ ┌───────────┐ │       │
│  │  │ users  │ │sessions │ │ accounts │ │verifications│ │       │
│  │  └────────┘ └─────────┘ └──────────┘ └───────────┘ │       │
│  └─────────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────┘
```

### Session Storage Strategy

**Cookie-Based Sessions** (No server-side session table lookup required per request):

```typescript
// src/lib/auth.ts
export const auth = betterAuth({
  session: {
    cookieCache: {
      enabled: true,        // Store session data in cookie
      maxAge: 60 * 5,       // Cache valid for 5 minutes before re-validation
    },
    expiresIn: 60 * 60 * 24 * 7,      // Session expires in 7 days (seconds)
    updateAge: 60 * 60 * 24,          // Refresh session if older than 1 day
  },
  advanced: {
    cookiePrefix: "blog_auth",        // Cookie name prefix
    useSecureCookies: true,           // HTTPS only in production
  },
});
```

**Cookie Configuration:**

| Setting | Value | Description |
|---------|-------|-------------|
| `httpOnly` | `true` | Prevents JavaScript access (XSS protection) |
| `secure` | `true` (prod) | HTTPS only |
| `sameSite` | `lax` | CSRF protection while allowing OAuth redirects |
| `maxAge` | `604800` (7 days) | Cookie expiry time in seconds |
| `path` | `/` | Cookie available site-wide |

**Session Lifecycle:**
1. User logs in → Session created in DB + cookie set with session token
2. Subsequent requests → Cookie sent automatically → Session validated
3. If `cookieCache` enabled → Session data cached in cookie, reduces DB lookups
4. After `expiresIn` → Session invalid, user must re-authenticate
5. If `updateAge` passed → Session refreshed (sliding expiration)

### Data Flow

1. **Sign Up/Sign In Flow**:
   - User clicks login button → Vue component calls `authClient.signIn.social()` or `authClient.signIn.email()`
   - Request hits `/api/auth/[...all].ts` → Better Auth handles OAuth redirect or credential verification
   - On success, session created in `sessions` table, cookie set
   - Middleware reads session, populates `Astro.locals.user` and `Astro.locals.session`

2. **Protected Route Access**:
   - User navigates to protected page (e.g., `/admin`)
   - Middleware intercepts, calls `auth.api.getSession()`
   - If no session → redirect to `/login`
   - If session but wrong role → redirect to `/403` or show error
   - If authorized → render page with user context

3. **Role Assignment Flow**:
   - Admin navigates to `/admin/users`
   - Page fetches user list via `auth.api.listUsers()`
   - Admin selects user, assigns new role
   - API call to `auth.api.setRole()` updates `users.role` column
   - Change logged for audit purposes

### Data Model & Migration

#### New Tables (Better Auth Core)

```sql
-- Better Auth will generate these via its schema
-- We need to extend the existing users table

-- users table (extended from existing)
ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;
ALTER TABLE users ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'user';
ALTER TABLE users ADD COLUMN IF NOT EXISTS banned BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS ban_reason TEXT;
ALTER TABLE users ADD COLUMN IF NOT EXISTS ban_expires TIMESTAMP;
ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW();

-- sessions table (new)
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMP NOT NULL,
  ip_address TEXT,
  user_agent TEXT,
  impersonated_by TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- accounts table (new - for OAuth providers)
CREATE TABLE accounts (
  id TEXT PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  provider_id TEXT NOT NULL,
  account_id TEXT NOT NULL,
  access_token TEXT,
  refresh_token TEXT,
  access_token_expires_at TIMESTAMP,
  refresh_token_expires_at TIMESTAMP,
  scope TEXT,
  password TEXT, -- hashed password for credential provider
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(provider_id, account_id)
);

-- verifications table (new - for email verification, password reset)
CREATE TABLE verifications (
  id TEXT PRIMARY KEY,
  identifier TEXT NOT NULL,
  value TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### Migration Strategy (Expand-Contract)

1. **EXPAND Phase**:
   - Add new columns to existing `users` table (additive, non-breaking)
   - Create new tables: `sessions`, `accounts`, `verifications`
   - No data loss, existing users preserved

2. **MIGRATE Phase**:
   - Existing users get default role `'user'`
   - First admin can be seeded via database or designated by user ID in config

3. **CONTRACT Phase**:
   - No removal needed for initial implementation
   - Future: Remove unused columns after validation period

#### Rollback SQL

```sql
-- Rollback migrations if needed
DROP TABLE IF EXISTS verifications;
DROP TABLE IF EXISTS accounts;
DROP TABLE IF EXISTS sessions;
ALTER TABLE users DROP COLUMN IF EXISTS email_verified;
ALTER TABLE users DROP COLUMN IF EXISTS image;
ALTER TABLE users DROP COLUMN IF EXISTS role;
ALTER TABLE users DROP COLUMN IF EXISTS banned;
ALTER TABLE users DROP COLUMN IF EXISTS ban_reason;
ALTER TABLE users DROP COLUMN IF EXISTS ban_expires;
ALTER TABLE users DROP COLUMN IF EXISTS updated_at;
```

## 4. Implementation Steps

### Phase 1: Preparation

- [ ] Create feature flag environment variable `FEATURE_RBAC_ENABLED`
- [ ] Define TypeScript interfaces for roles and permissions
- [ ] Update Drizzle schema with Better Auth tables
- [ ] Generate and apply database migrations
- [ ] Add environment variables for Google OAuth

### Phase 2: Core Authentication Setup

- [ ] Create Better Auth server configuration (`src/lib/auth.ts`)
- [ ] Configure email/password authentication
- [ ] Configure Google OAuth provider
- [ ] Create API route handler (`src/pages/api/auth/[...all].ts`)
- [ ] Create auth client for Vue (`src/lib/auth-client.ts`)
- [ ] Add TypeScript types to `env.d.ts`

### Phase 3: RBAC Implementation

- [ ] Configure Admin plugin with custom roles
- [ ] Define permission schema (Admin, Editor, User)
- [ ] Create access control helper functions
- [ ] Implement Astro middleware for route protection
- [ ] Create role-checking utilities

### Phase 4: UI Components

- [ ] Create login page with email/password form
- [ ] Add Google OAuth sign-in button
- [ ] Create registration page
- [ ] Build user profile component
- [ ] Create logout functionality
- [ ] Build admin user management page
- [ ] Add role assignment dropdown

### Phase 5: Protected Routes

- [ ] Create `/admin` layout with role check
- [ ] Protect admin routes (user management, settings)
- [ ] Create `/editor` layout for editor-only pages
- [ ] Add content moderation pages for editors
- [ ] Implement 403 Forbidden page

### Phase 6: Polish & Documentation

- [ ] Add loading states to auth components
- [ ] Implement error handling and user feedback
- [ ] Update CLAUDE.md with auth commands
- [ ] Add usage examples to README
- [ ] Clean up any temporary code

## 5. Operational Readiness

### Observability

| Type | Implementation |
|------|----------------|
| Logs | Log auth events: login, logout, role changes, failed attempts |
| Metrics | Track: auth latency, failed login rate, active sessions |
| Alerts | Alert on: 5+ failed logins/minute, session table growth anomaly |
| Dashboard | Display: active users, role distribution, auth method usage |

### Rollout Strategy

| Stage | % Users | Duration | Criteria |
|-------|---------|----------|----------|
| Development | 0% | N/A | Local testing only |
| Canary | 1% | 24h | Feature flag enabled for test users |
| Beta | 10% | 48h | No auth errors, latency < 500ms |
| GA | 100% | - | All metrics green, user feedback positive |

### Resource & Cost Impact

- **Compute**: Minimal - auth checks are lightweight DB queries
- **Storage**: ~1KB per user (session, account records)
- **Network**: OAuth redirects to Google (external)
- **Third-party**: Google OAuth is free
- **Infrastructure**: No new services required (uses existing Neon DB)

## 6. Security Considerations

| Risk | Mitigation |
|------|------------|
| Session hijacking | HTTP-only cookies, secure flag, SameSite=Lax |
| CSRF | Better Auth includes CSRF protection by default |
| Password attacks | Scrypt hashing, rate limiting on login |
| OAuth token theft | Short-lived access tokens, secure storage |
| Privilege escalation | Server-side role checks, never trust client |
| SQL injection | Drizzle ORM uses parameterized queries |
| XSS | Astro escapes output by default, CSP headers |
| IDOR | Check user owns resource before modification |

## 7. Performance Strategy

- **Session caching**: Consider Redis for session storage at scale (future)
- **Role caching**: Cache user role in session to avoid DB lookup per request
- **Query optimization**: Index `users.email`, `sessions.token`, `accounts.provider_id`
- **Lazy loading**: Load admin components only when needed
- **Connection pooling**: Neon handles connection pooling automatically

## 8. Testing Strategy

| Type | Coverage | Focus |
|------|----------|-------|
| Unit | 80%+ | Permission checking functions, role utilities |
| Integration | APIs | Auth endpoints, session management |
| E2E | Critical paths | Login flow, role assignment, protected routes |
| Edge Cases | Specific | Expired sessions, banned users, invalid tokens |
| Security | Auth | OWASP tests, penetration testing |

### Test Scenarios

1. **Happy Path**: User signs up → logs in → accesses allowed page
2. **Role Denied**: User tries to access admin page → redirected to 403
3. **Session Expiry**: Session expires → user redirected to login
4. **OAuth Flow**: User clicks Google → completes OAuth → session created
5. **Role Assignment**: Admin assigns editor role → user gains editor access
6. **Banned User**: Banned user tries to login → rejected with message

## 9. Rollback Plan

1. **Instant**: Set `FEATURE_RBAC_ENABLED=false` to disable auth checks
2. **Code Rollback**: Revert auth-related commits if critical bugs found
3. **Database**: Run rollback SQL only if data corruption detected
4. **Notify**: Alert users via banner if auth is temporarily disabled

## 10. Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Auth latency | < 500ms P95 | Server-side timing |
| Login success rate | > 99% | Successful logins / attempts |
| Role check latency | < 50ms | Middleware timing |
| User feedback | Positive | Qualitative user interviews |
| Zero security incidents | 0 | Security monitoring |

## 11. Post-Implementation Review (PIR)

- **Review Date**: Launch + 2 weeks
- **Metrics Check**: Validate all success metrics achieved
- **Lessons Learned**: Document what worked and what didn't
- **Action Items**: List follow-up improvements (MFA, email verification, etc.)

---

## Appendix A: File Structure

```
src/
├── lib/
│   ├── auth.ts              # Better Auth server config
│   ├── auth-client.ts       # Better Auth client (Vue)
│   ├── schema.ts            # Updated Drizzle schema
│   ├── db.ts                # Database connection (existing)
│   └── permissions.ts       # RBAC permission definitions
├── pages/
│   ├── api/
│   │   └── auth/
│   │       └── [...all].ts  # Better Auth API handler
│   ├── login.astro          # Login page
│   ├── register.astro       # Registration page
│   ├── 403.astro            # Forbidden page
│   └── admin/
│       ├── index.astro      # Admin dashboard
│       └── users.astro      # User management
├── components/
│   ├── LoginForm.vue        # Email/password form
│   ├── GoogleButton.vue     # OAuth button
│   ├── UserMenu.vue         # Profile dropdown
│   └── RoleSelector.vue     # Admin role assignment
├── middleware.ts            # Auth middleware
└── env.d.ts                 # TypeScript types
```

## Appendix B: Environment Variables

```env
# Database (existing)
DATABASE_URL=postgresql://...

# Better Auth
BETTER_AUTH_SECRET=<random-32-char-string>
BETTER_AUTH_URL=http://localhost:4321

# Session Configuration
SESSION_EXPIRY_DAYS=7          # Session expiry in days (default: 7)
SESSION_UPDATE_AGE_DAYS=1      # Refresh session if older than X days

# Google OAuth
GOOGLE_CLIENT_ID=<from-google-console>
GOOGLE_CLIENT_SECRET=<from-google-console>

# Feature Flags
FEATURE_RBAC_ENABLED=true
```

**Session Expiry Options:**

| Duration | `SESSION_EXPIRY_DAYS` | Use Case |
|----------|----------------------|----------|
| 1 day | `1` | High security (banking) |
| 7 days | `7` | Standard (recommended) |
| 30 days | `30` | Convenience (remember me) |
| 90 days | `90` | Low-risk applications |

## Appendix C: First Admin Bootstrap

**Problem**: How does the first admin get created?

**Solution**: Use Better Auth's `adminUserIds` configuration option:

```typescript
// src/lib/auth.ts
export const auth = betterAuth({
  // ... other config
  plugins: [
    admin({
      adminUserIds: [process.env.INITIAL_ADMIN_USER_ID], // Set via env var
      // OR after first user signs up, manually update DB:
      // UPDATE users SET role = 'admin' WHERE email = 'your@email.com';
    }),
  ],
});
```

**Bootstrap Steps**:
1. Deploy with `adminUserIds` empty or set to your expected user ID
2. Sign up with your email (you become user ID 1 or known ID)
3. Either: env var matches your ID → you're admin immediately
4. Or: Run SQL to promote yourself → remove `adminUserIds` config

## Appendix D: Session Cleanup Strategy

**Problem**: Sessions table can grow indefinitely.

**Solution**: Add a scheduled cleanup job:

```typescript
// scripts/cleanup-sessions.ts
import { db } from '../src/lib/db';
import { sessions } from '../src/lib/schema';
import { lt } from 'drizzle-orm';

// Delete expired sessions
await db.delete(sessions).where(lt(sessions.expiresAt, new Date()));
```

**Deployment Options**:
1. **Cron job**: Run daily via platform scheduler (Vercel cron, GitHub Actions)
2. **On-demand**: Call cleanup after each login (adds latency)
3. **TTL index**: If using PostgreSQL extensions, use pg_cron

**Recommended**: Run cleanup daily at low-traffic hours.

## Appendix E: Role Permissions Matrix

| Permission | Admin | Editor | User |
|------------|-------|--------|------|
| View public content | ✓ | ✓ | ✓ |
| View own profile | ✓ | ✓ | ✓ |
| Edit own profile | ✓ | ✓ | ✓ |
| Create blog posts | ✓ | ✓ | ✗ |
| Edit any blog post | ✓ | ✓ | ✗ |
| Delete any blog post | ✓ | ✓ | ✗ |
| View all users | ✓ | ✗ | ✗ |
| Manage user roles | ✓ | ✗ | ✗ |
| Ban/unban users | ✓ | ✗ | ✗ |
| Access site settings | ✓ | ✗ | ✗ |
| Impersonate users | ✓ | ✗ | ✗ |

## Appendix F: Critical Implementation Notes

### 1. Middleware Coverage
**Risk**: New routes added later may bypass auth checks.

**Mitigation**:
- Use path-based middleware patterns: `/admin/*`, `/editor/*`
- Add middleware tests that verify all protected routes are covered
- Code review checklist item: "Does new route need auth?"

### 2. OAuth Callback URL
**Risk**: Production deployment fails due to URL mismatch.

**Checklist**:
- [ ] Add `http://localhost:4321/api/auth/callback/google` to Google Console (dev)
- [ ] Add `https://yourdomain.com/api/auth/callback/google` to Google Console (prod)
- [ ] Set `BETTER_AUTH_URL` correctly per environment

### 3. Token Security
**Risk**: Tokens logged or exposed in client code.

**Rules**:
- Never log session tokens (use session ID instead)
- Never send tokens to client-side analytics
- Use HTTP-only cookies (Better Auth default)

### 4. Database Schema Compatibility
**Risk**: Better Auth expects specific column names.

**Note**: Better Auth can auto-generate schema. Run:
```bash
npx better-auth generate
```
This outputs the expected schema. Compare with our Drizzle schema to ensure compatibility.

---

**Sources:**
- [Better Auth Admin Plugin](https://www.better-auth.com/docs/plugins/admin)
- [Better Auth Google OAuth](https://www.better-auth.com/docs/authentication/google)
- [Better Auth Astro Integration](https://www.better-auth.com/docs/integrations/astro)
- [Better Auth Organization Plugin](https://www.better-auth.com/docs/plugins/organization)
