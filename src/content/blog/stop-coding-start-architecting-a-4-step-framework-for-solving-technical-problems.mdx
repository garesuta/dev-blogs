---
title: "Stop Coding, Start Architecting: A 4-Step Framework for Solving Technical Problems"
description: "Moving from vague business requests to concrete technical designs is the defining skill of a senior engineer. Here is the proven framework to bridge that gap"
pubDate: "2026-01-10T08:08:44.654Z"
heroImage: "https://bucket-production-bf69.up.railway.app/blog-images/uploads/1768032515366-3oobaq-Image.png"
---

### Introduction

As you advance in your engineering career, the problems change. You stop getting well-defined tickets like "Fix the button padding" and start getting ambiguous prompts like "We need a system to handle image uploads for 5 million users."

Many engineers panic. They dive straight into code or immediately start drawing database tables. This is a mistake. It leads to brittle systems that can't scale and don't actually solve the user's problem.

A Senior Engineer knows that design is a process, not a lightning strike of inspiration. To move from ambiguity to a solid technical plan, you need a repeatable framework.

Here is the 4-step process I use to analyze problems and structure solutions efficiently.

---

### Part 1: The Theory (The 4-Step Framework)

This framework is designed to progressively narrow down the problem space, moving from abstract business goals to concrete technical implementation details.

#### Step 1: Requirement Analysis (Defining the Boundaries)

Before you draw a single box, you must understand what you are building and, more importantly, the constraints under which it must operate.

* **Functional Requirements (The "What"):** These are the core features. What must the system *do*? (e.g., "Users can send messages," "The system must process payments.")
* **Non-Functional Requirements (The "How"):** These are the constraints that define system behavior. They are often the real architects of your solution.
* **Scale:** Are we designing for 1,000 users or 10 million?
* **Latency:** Does the response need to be under 100ms (real-time) or is 5 seconds okay (batch)?
* **Consistency:** Does everyone need to see data instantly, or is a short delay acceptable?



#### Step 2: High-Level Design (The Blueprint)

Once you know the boundaries, sketch the "30,000-foot view." We are identifying the major components and how data flows between them. We are *not* discussing specific technologies yet.

* *Key Questions:* What major services do we need? Where does the data live? Do we need caching?
* *Output:* A block diagram showing Load Balancers, Web Servers, Databases, and Caches connected by arrows indicating data flow.

#### Step 3: Low-Level Design (The Engine Room)

Now we zoom into the individual boxes from Step 2. This is where the design becomes actionable for developers.

* *Key Components:*
* **Database Schema:** Defining tables, relationships (FKs), and indexes necessary for performance.
* **API Contracts:** Defining endpoints (REST/gRPC), request payloads, and response structures.
* **Algorithms:** Addressing specific complex logic within a service (e.g., a recommendation ranking algorithm).



#### Step 4: Trade-offs & Reality Check (The Senior Mindset)

There is no perfect distributed system. Every design decision has a cost. A senior engineer explicitly identifies these costs.

* *Key Concepts:*
* **CAP Theorem:** Understanding that in the event of a network failure, you must choose between data Consistency (everyone sees the same thing) and Availability (the system keeps working).
* **Bottlenecks:** Identifying single points of failure. "What happens if the Redis instance dies?"



---

### Part 2: The Framework in Action (Example: A Simple News Feed)

Let’s apply the framework to a common prompt: **"Design a simplified social media news feed."**

#### 1. Requirement Analysis

* **Functional:** A user can post a status update. A user view a feed of updates from people they follow, sorted chronologically.
* **Non-Functional (Crucial):**
* *Read-Heavy:* People look at feeds 100x more often than they post. The system must be optimized for fast reads.
* *Latency:* The feed must load very quickly (sub-200ms) to feel responsive.
* *Availability:* It's better to show a slightly stale feed than an error message (Eventual Consistency is okay).



#### 2. High-Level Design (HLD)

Because it’s read-heavy and needs low latency, querying the database every time someone opens their app is too slow. We need a caching layer.

* **Components:** Client App  Load Balancer  Web Service  Relational DB (for storage).
* **Optimization:** We add a **Redis Cache** sitting in front of the DB. When a user requests their feed, we check Redis first.

#### 3. Low-Level Design (LLD)

How do we store this?

* **DB Schema (PostgreSQL):**
* `Users Table` (id, username)
* `Posts Table` (id, user_id, content, created_at)
* `Follows Table` (follower_id, followed_id)


* **API Contract:**
* `GET /api/v1/feed?userId=123`


* **The clever part (Fan-out on Write):** Because we need fast reads, when User A posts something, the system immediately finds all their followers, takes the post ID, and pushes it into their pre-computed Redis lists. The complex work happens on the *write*, making the *read* fast.

#### 4. Trade-offs

* **The Trade-off:** We chose "Fan-out on Write." This makes reading the feed incredibly fast. However, if a celebrity with 10 million followers makes a post, the system has to do 10 million instant updates to Redis caches. This results in "write lag."
* **The Resolution:** We accept this lag. It's acceptable for followers to see the post 30 seconds late, as long as their app loads instantly. We prioritized Availability over immediate Consistency.

---

### Part 3: Summarization Table

Here is a quick reference guide to what you should be focusing on in each stage.

| Stage | The Goal | The Output | Key Question to Ask |
| --- | --- | --- | --- |
| **1. Requirements** | Define boundaries & constraints. | A bulleted list of FRs and NFRs. | *"How much traffic must this handle, and how fast must it respond?"* |
| **2. High-Level** | Map the major components and data flow. | A block diagram with arrows. | *"How do the services communicate, and where does the data live?"* |
| **3. Low-Level** | Define implementation details for coders. | SQL schemas, API Specs (JSON/YAML). | *"What does the database table structure look like exactly?"* |
| **4. Trade-offs** | Identify weaknesses and costs. | A list of bottlenecks and accepted risks. | *"If this component fails right now, what happens to the user?"* |

---

### Part 4: How to Use This Efficiently

Knowing the steps isn't enough. You need to know how to navigate them without getting stuck. Here is how senior engineers use this framework efficiently.

**1. Do NOT start with the database.**
The biggest mistake junior engineers make is drawing tables in step 1. Database schemas are rigid. If you define them too early, you lock yourself into a design before you understand the constraints. Always start with NFRs.

**2. NFRs dictate the architecture.**
If the requirement is "100 users," your High-Level Design is a single server and a SQL database. If the requirement is "100 million users," your High-Level design needs load balancers, sharded databases, and caching layers. The features didn't change; the constraints did. Spend 40% of your time on Step 1.

**3. Timebox your phases.**
Analysis paralysis is real. In a 60-minute interview or a 2-hour whiteboard session, allocate your time strictly:

* Requirements: 15 mins
* High-Level: 15 mins
* Low-Level: 20 mins
* Trade-offs: 10 mins

**4. It is iterative, not linear.**
You will get to Step 3 (Database Schema) and realize it won't support the scale you defined in Step 1. *That is allowed.* Go back to Step 2 and change the architecture (e.g., switch from SQL to NoSQL). The framework is a loop, not a straight line.